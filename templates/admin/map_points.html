{% extends "admin/change_form.html" %}
{% load value_from_settings %}
{% block extrahead %}
    {{ block.super }}
    <link rel="stylesheet" href="/static/css/colorPicker.css" type="text/css" media="all"/>
    <link rel="stylesheet" href="/static/css/jquery-ui-1.8.14.smoothness.css" type="text/css" media="all"/>
    <link rel="stylesheet" href="/static/css/jquery.ui.selectmenu.css" type="text/css" media="all"/>

    <style type="text/css">
        .colMS {
            margin-left: 36% !important;
        }

        #content-related {
            position: static;
        }

        #map_container {
            width: 35%;
            height: 650px;
            top: 89px;
            left: 0;
            position: fixed;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .editing {
            font-weight: bold;
        }

        .row-dragging {
            background-color: #ffd385;
        }
        .color_rect {

            width: 10px;
            height: 10px;
            display: block;
            position: absolute;
            border: 1px solid white;

            top: 8px;
            left: 4px;
        }
        li > a > .color_rect {
            top: 3px;
            left: auto;
            margin-left: -5px;
            position: relative;
            float: left;
        }
        .ui-selectmenu-status {
            padding-right: 23px;
        }
        .ui-selectmenu-menu-dropdown {
            -webkit-padding-start: 0;
        }
}
    </style>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jqueryui/1.8.13/jquery-ui.min.js"></script>
    <script src="/static/js/libs/jquery.colorPicker.js"></script>
    <script src="/static/js/libs/jquery.tablednd_0_5.js"></script>
    <script src="http://api.navigator.telmap.com/maps/api/js?sensor=false"></script>
    <script type="text/javascript" src="/static/js/utils.js"></script>
    <script src="/static/js/ordering.js"></script>

    <script type="text/javascript">
    function addColor(text, element) {
        if (text != '---------') {
            return text + "<span class='color_rect'></span>"
        } else {
            return text
        }
    }
    function initColors(id) {
        if (!id ) {
            return;
        }
        var parent_type = id.match(/#id_(\w+)/)[1];
        id = id.replace(/__prefix__/, $("#id_" + parent_type + "-TOTAL_FORMS").val() - 1);
        
        $(id).selectmenu({
            format: addColor
        });
        
        var colors = $(document).data("colors");
        var new_options = $(id + "-menu").find(".color_rect");
        $(id).find("option").not("option[value=]").each(function(i, element) {
            var new_option = new_options[i];
            var color = colors[$(element).val()];
            $(new_option).css({ "background-color": color });
            if ($(element).is(":selected")) {
                $(id + "-button").find(".color_rect").css({ "background-color": color });
            }
        });
    }
     /*
 * jQuery UI selectmenu dev version
 *
 * Copyright (c) 2009 AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * http://docs.jquery.com/UI
 * https://github.com/fnagel/jquery-ui/wiki/Selectmenu
 */

(function($) {

$.widget("ui.selectmenu", {
	getter: "value",
	version: "1.8",
	eventPrefix: "selectmenu",
	options: {
		transferClasses: true,
		typeAhead: "sequential",
		style: 'dropdown',
		positionOptions: {
			my: "left top",
			at: "left bottom",
			offset: null
		},
		width: null,
        element: null,
		menuWidth: null,
		handleWidth: 26,
		maxHeight: null,
		icons: null,
		format: null,
		bgImage: function() {},
		wrapperElement: "<div />"
	},

	_create: function() {
		var self = this, o = this.options;
        o.element = this.element;
		// set a default id value, generate a new random one if not set by developer
		var selectmenuId = this.element.attr( 'id' ) || 'ui-selectmenu-' + Math.random().toString( 16 ).slice( 2, 10 );

		// quick array of button and menu id's
		this.ids = [ selectmenuId + '-button', selectmenuId + '-menu' ];

		// define safe mouseup for future toggling
		this._safemouseup = true;

		// create menu button wrapper
		this.newelement = $( '<a />', {
			'class': this.widgetBaseClass + ' ui-widget ui-state-default ui-corner-all',
			'id' : this.ids[ 0 ],
			'role': 'button',
			'href': '#',
			'tabindex': '0' ,
			'aria-haspopup': true,
			'aria-owns': this.ids[ 1 ]
		});
		this.newelementWrap = $( o.wrapperElement )
			.append( this.newelement )
			.insertAfter( this.element );

		// transfer tabindex
		var tabindex = this.element.attr( 'tabindex' );
		if ( tabindex ) {
			this.newelement.attr( 'tabindex', tabindex );
		}

		// save reference to select in data for ease in calling methods
		this.newelement.data( 'selectelement', this.element );

		// menu icon
		this.selectmenuIcon = $( '<span class="' + this.widgetBaseClass + '-icon ui-icon"></span>' )
			.prependTo( this.newelement );

		// append status span to button
		this.newelement.prepend( '<span class="' + self.widgetBaseClass + '-status" />' );

		// make associated form label trigger focus
		$( 'label[for="' + selectmenuId + '"]' )
			.attr( 'for', this.ids[0] )
			.bind( 'click.selectmenu', function() {
				self.newelement[0].focus();
				return false;
			});

		// click toggle for menu visibility
		this.newelement
			.bind('mousedown.selectmenu', function(event) {
				self._toggle(event, true);
				// make sure a click won't open/close instantly
				if (o.style == "popup") {
					self._safemouseup = false;
					setTimeout(function() { self._safemouseup = true; }, 300);
				}
				return false;
			})
			.bind('click.selectmenu', function() {
				return false;
			})
			.bind("keydown.selectmenu", function(event) {
				var ret = false;
				switch (event.keyCode) {
					case $.ui.keyCode.ENTER:
						ret = true;
						break;
					case $.ui.keyCode.SPACE:
						self._toggle(event);
						break;
					case $.ui.keyCode.UP:
						if (event.altKey) {
							self.open(event);
						} else {
							self._moveSelection(-1);
						}
						break;
					case $.ui.keyCode.DOWN:
						if (event.altKey) {
							self.open(event);
						} else {
							self._moveSelection(1);
						}
						break;
					case $.ui.keyCode.LEFT:
						self._moveSelection(-1);
						break;
					case $.ui.keyCode.RIGHT:
						self._moveSelection(1);
						break;
					case $.ui.keyCode.TAB:
						ret = true;
						break;
					default:
						ret = true;
				}
				return ret;
			})
			.bind('keypress.selectmenu', function(event) {
				self._typeAhead(event.which, 'mouseup');
				return true;
			})
			.bind('mouseover.selectmenu focus.selectmenu', function() {
				if (!o.disabled) {
					$(this).addClass(self.widgetBaseClass + '-focus ui-state-hover');
				}
			})
			.bind('mouseout.selectmenu blur.selectmenu', function() {
				if (!o.disabled) {
					$(this).removeClass(self.widgetBaseClass + '-focus ui-state-hover');
				}
			});

		// document click closes menu
		$(document).bind("mousedown.selectmenu", function(event) {
			self.close(event);
		});

		// change event on original selectmenu
		this.element
			.bind("click.selectmenu", function() {
				self._refreshValue();
			})
			// FIXME: newelement can be null under unclear circumstances in IE8
			// TODO not sure if this is still a problem (fnagel 20.03.11)
			.bind("focus.selectmenu", function() {
				if (self.newelement) {
					self.newelement[0].focus();
				}
			});

		// set width when not set via options
		if (!o.width) {
			o.width = this.element.outerWidth() + 20;
		}
		// set menu button width
		this.newelement.width(o.width);

		// hide original selectmenu element
		this.element.hide();

		// create menu portion, append to body
		this.list = $( '<ul />', {
			'class': 'ui-widget ui-widget-content',
			'aria-hidden': true,
			'role': 'listbox',
			'aria-labelledby': this.ids[0],
			'id': this.ids[1]
		});
		this.listWrap = $( o.wrapperElement )
			.addClass( self.widgetBaseClass + '-menu' )
			.append( this.list )
			.appendTo( 'body' );

		// transfer menu click to menu button
		this.list
			.bind("keydown.selectmenu", function(event) {
				var ret = false;
				switch (event.keyCode) {
					case $.ui.keyCode.UP:
						if (event.altKey) {
							self.close(event, true);
						} else {
							self._moveFocus(-1);
						}
						break;
					case $.ui.keyCode.DOWN:
						if (event.altKey) {
							self.close(event, true);
						} else {
							self._moveFocus(1);
						}
						break;
					case $.ui.keyCode.LEFT:
						self._moveFocus(-1);
						break;
					case $.ui.keyCode.RIGHT:
						self._moveFocus(1);
						break;
					case $.ui.keyCode.HOME:
						self._moveFocus(':first');
						break;
					case $.ui.keyCode.PAGE_UP:
						self._scrollPage('up');
						break;
					case $.ui.keyCode.PAGE_DOWN:
						self._scrollPage('down');
						break;
					case $.ui.keyCode.END:
						self._moveFocus(':last');
						break;
					case $.ui.keyCode.ENTER:
					case $.ui.keyCode.SPACE:
						self.close(event, true);
						$(event.target).parents('li:eq(0)').trigger('mouseup');
						break;
					case $.ui.keyCode.TAB:
						ret = true;
						self.close(event, true);
						$(event.target).parents('li:eq(0)').trigger('mouseup');
						break;
					case $.ui.keyCode.ESCAPE:
						self.close(event, true);
						break;
					default:
						ret = true;
				}
				return ret;
			})
			.bind('keypress.selectmenu', function(event) {
				self._typeAhead(event.which, 'focus');
				return true;
			})
			// this allows for using the scrollbar in an overflowed list
			.bind( 'mousedown.selectmenu mouseup.selectmenu', function() { return false; });

		// needed when window is resized
		// TODO seems to be useless, but causes errors (fnagel 01.08.11)
		// see: https://github.com/fnagel/jquery-ui/issues/147
		// $(window).bind( "resize.selectmenu", $.proxy( self._refreshPosition, this ) );
	},

	_init: function() {
		var self = this, o = this.options;

		// serialize selectmenu element options
		var selectOptionData = [];
		this.element
			.find('option')
			.each(function() {
				var opt = $(this);
				selectOptionData.push({
					value: opt.attr('value'),
					text: self._formatText(opt.text()),
					selected: opt.attr('selected'),
					disabled: opt.attr('disabled'),
					classes: opt.attr('class'),
					typeahead: opt.attr('typeahead'),
					parentOptGroup: opt.parent('optgroup'),
					bgImage: o.bgImage.call(opt)
				});
			});

		// active state class is only used in popup style
		var activeClass = (self.options.style == "popup") ? " ui-state-active" : "";

		// empty list so we can refresh the selectmenu via selectmenu()
		this.list.html("");

		// write li's
		if (selectOptionData.length) {
			for (var i = 0; i < selectOptionData.length; i++) {
				var thisLiAttr = { role : 'presentation' };
				if ( selectOptionData[ i ].disabled ) {
					thisLiAttr[ 'class' ] = this.namespace + '-state-disabled';
				}
				var thisAAttr = {
					html: selectOptionData[i].text,
					href : '#',
					tabindex : -1,
					role : 'option',
					'aria-selected' : false
				};
				if ( selectOptionData[ i ].disabled ) {
					thisAAttr[ 'aria-disabled' ] = selectOptionData[ i ].disabled;
				}
				if ( selectOptionData[ i ].typeahead ) {
					thisAAttr[ 'typeahead' ] = selectOptionData[ i ].typeahead;
				}
				var thisA = $('<a/>', thisAAttr);
				var thisLi = $('<li/>', thisLiAttr)
					.append(thisA)
					.data('index', i)
					.addClass(selectOptionData[i].classes)
					.data('optionClasses', selectOptionData[i].classes || '')
					.bind("mouseup.selectmenu", function(event) {
						if (self._safemouseup && !self._disabled(event.currentTarget) && !self._disabled($( event.currentTarget ).parents( "ul>li." + self.widgetBaseClass + "-group " )) ) {
							var changed = $(this).data('index') != self._selectedIndex();
							self.index($(this).data('index'));
							self.select(event);
							if (changed) {
								self.change(event);
							}
							self.close(event, true);
						}
						return false;
					})
					.bind("click.selectmenu", function() {
						return false;
					})
					.bind('mouseover.selectmenu focus.selectmenu', function(e) {
						// no hover if diabled
						if (!$(e.currentTarget).hasClass(self.namespace + '-state-disabled') && !$(e.currentTarget).parent("ul").parent("li").hasClass(self.namespace + '-state-disabled')) {
							self._selectedOptionLi().addClass(activeClass);
							self._focusedOptionLi().removeClass(self.widgetBaseClass + '-item-focus ui-state-hover');
							$(this).removeClass('ui-state-active').addClass(self.widgetBaseClass + '-item-focus ui-state-hover');
						}
					})
					.bind('mouseout.selectmenu blur.selectmenu', function() {
						if ($(this).is(self._selectedOptionLi().selector)) {
							$(this).addClass(activeClass);
						}
						$(this).removeClass(self.widgetBaseClass + '-item-focus ui-state-hover');
					});

				// optgroup or not...
				if ( selectOptionData[i].parentOptGroup.length ) {
					var optGroupName = self.widgetBaseClass + '-group-' + this.element.find( 'optgroup' ).index( selectOptionData[i].parentOptGroup );
					if (this.list.find( 'li.' + optGroupName ).length ) {
						this.list.find( 'li.' + optGroupName + ':last ul' ).append( thisLi );
					} else {
						$(' <li role="presentation" class="' + self.widgetBaseClass + '-group ' + optGroupName + (selectOptionData[i].parentOptGroup.attr("disabled") ? ' ' + this.namespace + '-state-disabled" aria-disabled="true"' : '"' ) + '><span class="' + self.widgetBaseClass + '-group-label">' + selectOptionData[i].parentOptGroup.attr('label') + '</span><ul></ul></li> ')
							.appendTo( this.list )
							.find( 'ul' )
							.append( thisLi );
					}
				} else {
					thisLi.appendTo(this.list);
				}

				// append icon if option is specified
				if (o.icons) {
					for (var j in o.icons) {
						if (thisLi.is(o.icons[j].find)) {
							thisLi
								.data('optionClasses', selectOptionData[i].classes + ' ' + self.widgetBaseClass + '-hasIcon')
								.addClass(self.widgetBaseClass + '-hasIcon');
							var iconClass = o.icons[j].icon || "";
							thisLi
								.find('a:eq(0)')
								.prepend('<span class="' + self.widgetBaseClass + '-item-icon ui-icon ' + iconClass + '"></span>');
							if (selectOptionData[i].bgImage) {
								thisLi.find('span').css('background-image', selectOptionData[i].bgImage);
							}
						}
					}
				}
			}
		} else {
			$('<li role="presentation"><a href="#" tabindex="-1" role="option"></a></li>').appendTo(this.list);
		}
		// we need to set and unset the CSS classes for dropdown and popup style
		var isDropDown = ( o.style == 'dropdown' );
		this.newelement
			.toggleClass( self.widgetBaseClass + '-dropdown', isDropDown )
			.toggleClass( self.widgetBaseClass + '-popup', !isDropDown );
		this.list
			.toggleClass( self.widgetBaseClass + '-menu-dropdown ui-corner-bottom', isDropDown )
			.toggleClass( self.widgetBaseClass + '-menu-popup ui-corner-all', !isDropDown )
			// add corners to top and bottom menu items
			.find( 'li:first' )
			.toggleClass( 'ui-corner-top', !isDropDown )
			.end().find( 'li:last' )
			.addClass( 'ui-corner-bottom' );
		this.selectmenuIcon
			.toggleClass( 'ui-icon-triangle-1-s', isDropDown )
			.toggleClass( 'ui-icon-triangle-2-n-s', !isDropDown );

		// transfer classes to selectmenu and list
		if ( o.transferClasses ) {
			var transferClasses = this.element.attr( 'class' ) || '';
			this.newelement.add( this.list ).addClass( transferClasses );
		}

		// set menu width to either menuWidth option value, width option value, or select width
		if ( o.style == 'dropdown' ) {
			this.list.width( o.menuWidth ? o.menuWidth : o.width );
		} else {
			this.list.width( o.menuWidth ? o.menuWidth : o.width - o.handleWidth );
		}

		// reset height to auto
		this.list.css( 'height', 'auto' );
		var listH = this.listWrap.height();
		// calculate default max height
		if ( o.maxHeight && o.maxHeight < listH ) {
			this.list.height( o.maxHeight );
		} else {
			var winH = $( window ).height() / 3;
			if ( winH < listH ) this.list.height( winH );
		}

		// save reference to actionable li's (not group label li's)
		this._optionLis = this.list.find( 'li:not(.' + self.widgetBaseClass + '-group)' );

		// transfer disabled state
		if ( this.element.attr( 'disabled' ) ) {
			this.disable();
		} else {
			this.enable()
		}

		// update value
		this.index( this._selectedIndex() );

		// needed when selectmenu is placed at the very bottom / top of the page
		window.setTimeout( function() {
			self._refreshPosition();
		}, 200 );
	},

	destroy: function() {
		this.element.removeData( this.widgetName )
			.removeClass( this.widgetBaseClass + '-disabled' + ' ' + this.namespace + '-state-disabled' )
			.removeAttr( 'aria-disabled' )
			.unbind( ".selectmenu" );

		// TODO unneded as event binding has been disabled
		// $( window ).unbind( ".selectmenu" );
		$( document ).unbind( ".selectmenu" );

		// unbind click on label, reset its for attr
		$( 'label[for=' + this.newelement.attr('id') + ']' )
			.attr( 'for', this.element.attr( 'id' ) )
			.unbind( '.selectmenu' );

		this.newelementWrap.remove();
		this.listWrap.remove();

		this.element.show();

		// call widget destroy function
		$.Widget.prototype.destroy.apply(this, arguments);
	},

	_typeAhead: function( code, eventType ){
		var self = this, focusFound = false, C = String.fromCharCode(code).toUpperCase();
		c = C.toLowerCase();

		if ( self.options.typeAhead == 'sequential' ) {
			// clear the timeout so we can use _prevChar
			window.clearTimeout('ui.selectmenu-' + self.selectmenuId);

			// define our find var
			var find = typeof( self._prevChar ) == 'undefined' ? '' : self._prevChar.join( '' );

			function focusOptSeq( elem, ind, c ){
				focusFound = true;
				$( elem ).trigger( eventType );
				typeof( self._prevChar ) == 'undefined' ? self._prevChar = [ c ] : self._prevChar[ self._prevChar.length ] = c;
			}
			this.list.find( 'li a' ).each( function( i ) {
				if ( !focusFound ) {
					// allow the typeahead attribute on the option tag for a more specific lookup
					var thisText = $( this ).attr( 'typeahead' ) || $(this).text();
					if ( thisText.indexOf( find + C ) === 0 ) {
						focusOptSeq( this, i, C );
					} else if (thisText.indexOf(find+c) === 0 ) {
						focusOptSeq( this, i, c );
					}
				}
			});
			// set a 1 second timeout for sequenctial typeahead
			// keep this set even if we have no matches so it doesnt typeahead somewhere else
			window.setTimeout( function( el ) {
				self._prevChar = undefined;
			}, 1000, self );

		} else {
			// define self._prevChar if needed
			if ( !self._prevChar ) { self._prevChar = [ '' , 0 ]; }

			focusFound = false;
			function focusOpt( elem, ind ){
				focusFound = true;
				$( elem ).trigger( eventType );
				self._prevChar[ 1 ] = ind;
			}
			this.list.find( 'li a' ).each(function( i ){
				if (!focusFound){
					var thisText = $(this).text();
					if ( thisText.indexOf( C ) === 0 || thisText.indexOf( c ) === 0 ) {
						if (self._prevChar[0] == C){
							if ( self._prevChar[ 1 ] < i ){ focusOpt( this, i ); }
						} else{
							focusOpt( this, i );
						}
					}
				}
			});
			this._prevChar[ 0 ] = C;
		}
	},

	// returns some usefull information, called by callbacks only
	_uiHash: function() {
		var index = this.index();
		return {
			index: index,
			option: $("option", this.element).get(index),
			value: this.element[0].value
		};
	},

	open: function(event) {
		var self = this, o = this.options;
		if ( self.newelement.attr("aria-disabled") != 'true' ) {
			self._closeOthers(event);
			self.newelement.addClass('ui-state-active');

			self.listWrap.appendTo( o.appendTo );
			self.list.attr('aria-hidden', false);

			if ( o.style == "dropdown" ) {
				self.newelement.removeClass('ui-corner-all').addClass('ui-corner-top');
			}

			self.listWrap.addClass( self.widgetBaseClass + '-open' );
			// positioning needed for IE7 (tested 01.08.11 on MS VPC Image)
			// see https://github.com/fnagel/jquery-ui/issues/147
			if ( $.browser.msie && $.browser.version.substr( 0,1 ) == 7 ) {
				self._refreshPosition();
			}
			var selected = self.list.attr('aria-hidden', false).find('li:not(.' + self.widgetBaseClass + '-group):eq(' + self._selectedIndex() + ') a');
			if (selected.length) selected[0].focus();
			// positioning needed for FF, Chrome, IE8, IE7, IE6 (tested 01.08.11 on MS VPC Image)
			self._refreshPosition();

			self._trigger("open", event, self._uiHash());
		}
	},

	close: function(event, retainFocus) {
		if ( this.newelement.is('.ui-state-active') ) {
			this.newelement
				.removeClass('ui-state-active');
			this.listWrap.removeClass(this.widgetBaseClass + '-open');
			this.list.attr('aria-hidden', true);
			if ( this.options.style == "dropdown" ) {
				this.newelement.removeClass('ui-corner-top').addClass('ui-corner-all');
			}
			if ( retainFocus ) {
				this.newelement.focus();
			}
			this._trigger("close", event, this._uiHash());
		}
	},

	change: function(event) {
		this.element.trigger("change");
		this._trigger("change", event, this._uiHash());
	},

	select: function(event) {
		if (this._disabled(event.currentTarget)) { return false; }
		this._trigger("select", event, this._uiHash());
	},

	_closeOthers: function(event) {
		$('.' + this.widgetBaseClass + '.ui-state-active').not(this.newelement).each(function() {
			$(this).data('selectelement').selectmenu('close', event);
		});
		$('.' + this.widgetBaseClass + '.ui-state-hover').trigger('mouseout');
	},

	_toggle: function(event, retainFocus) {
		if ( this.list.is('.' + this.widgetBaseClass + '-open') ) {
			this.close(event, retainFocus);
		} else {
			this.open(event);
		}
	},

	_formatText: function(text) {
		return (this.options.format ? this.options.format(text, this.newelement) : text);
	},

	_selectedIndex: function() {
		return this.element[0].selectedIndex;
	},

	_selectedOptionLi: function() {
		return this._optionLis.eq(this._selectedIndex());
	},

	_focusedOptionLi: function() {
		return this.list.find('.' + this.widgetBaseClass + '-item-focus');
	},

	_moveSelection: function(amt, recIndex) {
		// do nothing if disabled
		if (!this.options.disabled) {
			var currIndex = parseInt(this._selectedOptionLi().data('index') || 0, 10);
			var newIndex = currIndex + amt;
			// do not loop when using up key

			if (newIndex < 0) {
				newIndex = 0;
			}
			if (newIndex > this._optionLis.size() - 1) {
				newIndex = this._optionLis.size() - 1;
			}
			// Occurs when a full loop has been made
			if (newIndex === recIndex) { return false; }

			if (this._optionLis.eq(newIndex).hasClass( this.namespace + '-state-disabled' )) {
				// if option at newIndex is disabled, call _moveFocus, incrementing amt by one
				(amt > 0) ? ++amt : --amt;
				this._moveSelection(amt, newIndex);
			} else {
				return this._optionLis.eq(newIndex).trigger('mouseup');
			}
		}
	},

	_moveFocus: function(amt, recIndex) {
		if (!isNaN(amt)) {
			var currIndex = parseInt(this._focusedOptionLi().data('index') || 0, 10);
			var newIndex = currIndex + amt;
		} else {
			var newIndex = parseInt(this._optionLis.filter(amt).data('index'), 10);
		}

		if (newIndex < 0) {
			newIndex = 0;
		}
		if (newIndex > this._optionLis.size() - 1) {
			newIndex = this._optionLis.size() - 1;
		}

		//Occurs when a full loop has been made
		if (newIndex === recIndex) { return false; }

		var activeID = this.widgetBaseClass + '-item-' + Math.round(Math.random() * 1000);

		this._focusedOptionLi().find('a:eq(0)').attr('id', '');

		if (this._optionLis.eq(newIndex).hasClass( this.namespace + '-state-disabled' )) {
			// if option at newIndex is disabled, call _moveFocus, incrementing amt by one
			(amt > 0) ? ++amt : --amt;
			this._moveFocus(amt, newIndex);
		} else {
			this._optionLis.eq(newIndex).find('a:eq(0)').attr('id',activeID).focus();
		}

		this.list.attr('aria-activedescendant', activeID);
	},

	_scrollPage: function(direction) {
		var numPerPage = Math.floor(this.list.outerHeight() / this.list.find('li:first').outerHeight());
		numPerPage = (direction == 'up' ? -numPerPage : numPerPage);
		this._moveFocus(numPerPage);
	},

	_setOption: function(key, value) {
		this.options[key] = value;
		// set
		if (key == 'disabled') {
			this.close();
			this.element
				.add(this.newelement)
				.add(this.list)[value ? 'addClass' : 'removeClass'](
					this.widgetBaseClass + '-disabled' + ' ' +
					this.namespace + '-state-disabled')
				.attr("aria-disabled", value);
		}
	},

	disable: function(index, type){
			// if options is not provided, call the parents disable function
			if ( typeof( index ) == 'undefined' ) {
				this._setOption( 'disabled', true );
			} else {
				if ( type == "optgroup" ) {
					this._disableOptgroup(index);
				} else {
					this._disableOption(index);
				}
			}
	},

	enable: function(index, type) {
			// if options is not provided, call the parents enable function
			if ( typeof( index ) == 'undefined' ) {
				this._setOption('disabled', false);
			} else {
				if ( type == "optgroup" ) {
					this._enableOptgroup(index);
				} else {
					this._enableOption(index);
				}
			}
	},

	_disabled: function(elem) {
			return $(elem).hasClass( this.namespace + '-state-disabled' );
	},


	_disableOption: function(index) {
			var optionElem = this._optionLis.eq(index);
			if (optionElem) {
				optionElem.addClass(this.namespace + '-state-disabled')
					.find("a").attr("aria-disabled", true);
				this.element.find("option").eq(index).attr("disabled", "disabled");
			}
	},

	_enableOption: function(index) {
			var optionElem = this._optionLis.eq(index);
			if (optionElem) {
				optionElem.removeClass( this.namespace + '-state-disabled' )
					.find("a").attr("aria-disabled", false);
				this.element.find("option").eq(index).removeAttr("disabled");
			}
	},

	_disableOptgroup: function(index) {
			var optGroupElem = this.list.find( 'li.' + this.widgetBaseClass + '-group-' + index );
			if (optGroupElem) {
				optGroupElem.addClass(this.namespace + '-state-disabled')
					.attr("aria-disabled", true);
				this.element.find("optgroup").eq(index).attr("disabled", "disabled");
			}
	},

	_enableOptgroup: function(index) {
			var optGroupElem = this.list.find( 'li.' + this.widgetBaseClass + '-group-' + index );
			if (optGroupElem) {
				optGroupElem.removeClass(this.namespace + '-state-disabled')
					.attr("aria-disabled", false);
				this.element.find("optgroup").eq(index).removeAttr("disabled");
			}
	},

	index: function(newValue) {
		if (arguments.length) {
			if (!this._disabled($(this._optionLis[newValue]))) {
				this.element[0].selectedIndex = newValue;
				this._refreshValue();
			} else {
				return false;
			}
		} else {
			return this._selectedIndex();
		}
	},

	value: function(newValue) {
		if (arguments.length) {
			this.element[0].value = newValue;
			this._refreshValue();
		} else {
			return this.element[0].value;
		}
	},

	_refreshValue: function() {
		var activeClass = (this.options.style == "popup") ? " ui-state-active" : "";
		var activeID = this.widgetBaseClass + '-item-' + Math.round(Math.random() * 1000);
		// deselect previous
		this.list
			.find('.' + this.widgetBaseClass + '-item-selected')
			.removeClass(this.widgetBaseClass + "-item-selected" + activeClass)
			.find('a')
			.attr('aria-selected', 'false')
			.attr('id', '');
		// select new
		this._selectedOptionLi()
			.addClass(this.widgetBaseClass + "-item-selected" + activeClass)
			.find('a')
			.attr('aria-selected', 'true')
			.attr('id', activeID);

		// toggle any class brought in from option
		var currentOptionClasses = (this.newelement.data('optionClasses') ? this.newelement.data('optionClasses') : "");
		var newOptionClasses = (this._selectedOptionLi().data('optionClasses') ? this._selectedOptionLi().data('optionClasses') : "");
		this.newelement
			.removeClass(currentOptionClasses)
			.data('optionClasses', newOptionClasses)
			.addClass( newOptionClasses )
			.find('.' + this.widgetBaseClass + '-status')
			.html(
				this._selectedOptionLi()
					.find('a:eq(0)')
					.html()
			);

		this.list.attr('aria-activedescendant', activeID);
	},

	_refreshPosition: function() {
		var o = this.options;

		// if its a native pop-up we need to calculate the position of the selected li
		if ( o.style == "popup" && !o.positionOptions.offset ) {
			var selected = this._selectedOptionLi();
			var _offset = "0 -" + ( selected.outerHeight() + selected.offset().top - this.list.offset().top );
		}
		// update zIndex if jQuery UI is able to process
		var zIndexElement = this.element.zIndex();
		if ( zIndexElement ) {
			this.listWrap.css( 'zIndex', zIndexElement );
		}
		this.listWrap.position({
			// set options for position plugin
			of: o.positionOptions.of || this.newelement,
			my: o.positionOptions.my,
			at: o.positionOptions.at,
			offset: o.positionOptions.offset || _offset,
			collision: o.positionOptions.collision || 'flip'
		});
	}
});

})(jQuery);
    </script>
    <script type="text/javascript">

    var MapPointsHelper = Object.create({
        polygons			    : {},
        map_listeners		    : [],
        polygon_listeners		: [],
        currently_editing_id	: undefined,
        drag_marker			    : undefined,
        last_listener		    : undefined,

        removeDragMarker        : function () {
            if (this.drag_marker) {
                this.drag_marker.setMap();
                this.drag_marker = undefined;
            }
        },

        removeListeners         : function () {
            $.each(this.map_listeners, function(i, e) {
                telmap.maps.event.removeListener(e);
            });

            $.each(this.polygon_listeners, function(i, e) {
                telmap.maps.event.removeListener(e);
            });
        },

        centerMap               : function () {
            var that = this;
            var bounds = new telmap.maps.LatLngBounds();
            $.each(that.polygons, function(i, polygon) {
                $.each(polygon.getPath().array, function(i, point) {
                    bounds.extend(point);
                })
            });

            OrderingHelper.map.fitBounds(bounds);
            OrderingHelper.map.panToBounds(bounds);
        },

        renderPolygons          : function () {
            var that = this;
            $(".points").find("input[type=hidden]").each(function(i, e) {
                var val = $(e).val();
                if (val) {
                    var val_array = val.split("|");
                    var polygon = that.getPolygon(e.id);
                    $.each(val_array, function(i, e) {
                        if (i % 2 == 0) {
                            that.updatePolygonPoint(polygon, -1, val_array[i], val_array[i + 1]);
                        }
                    });
                    console.log("found val:" + val);
                }
            })
        },

        updatePolygonPoint      : function (polygon, index, lat, lng) {
            var path = polygon.getPath() || new telmap.maps.MVCArray([]);
            var point = new telmap.maps.LatLng(lat, lng);

            if (index > path.getLength() || index < 0) {
                path.push(point);
            } else {
                path.setAt(index, point);
            }
            polygon.setPath(path);
            polygon.setMap(OrderingHelper.map);

        },

        pointDistance           : function (p1, p2) {
            return Math.sqrt(Math.pow((p1.lat() - p2.lat()), 2) + Math.pow((p1.lng() - p2.lng()), 2));
        },

        getPolygon              : function (id, color) {
            var that = this;
            if (! (id in that.polygons)) {
                console.log("creating new polygon: " + id);

                if (!color) {
                    color = $("#" + id.replace("points", "color")).val();
                }
                that.polygons[id] = new telmap.maps.Polygon({
                    fillColor: color,
                    fillOpacity: 0.4,
                    strokeColor: color,
                    strokeOpacity: 1.0,
                    strokeWeight: 2,
                    path: new telmap.maps.MVCArray([])
                });

                // redispatch mouse events to map
                telmap.maps.event.addListener(that.polygons[id], "click", function(e) {
                    telmap.maps.event.trigger(OrderingHelper.map, "click", e);
                });
                telmap.maps.event.addListener(that.polygons[id], "mousemove", function(e) {
                    telmap.maps.event.trigger(OrderingHelper.map, "mousemove", e);
                });
            }
            return that.polygons[id];
        },

        doEditPolygon           : function (id) {
            var that = this;
            if (that.currently_editing_id) {
                // clear old listeners
                that.removeListeners();
                that.removeDragMarker();
                $("#edit-" + id).removeClass("editing").text("Edit");

                // update stored val
                var path = that.getPolygon(id).getPath();
                if (path) {
                    var val_array = [];
                    $.each(path.array, function(i, e) {
                        val_array.push(e.lat());
                        val_array.push(e.lng());
                    });
                    $("#" + id).val(val_array.join("|"));
                }
            }

            if (id == that.currently_editing_id) { // just stop editing
                that.currently_editing_id = undefined;
            } else { // start editing another polygon
                that.currently_editing_id = id;
                $("#edit-" + id).addClass("editing").text("Done");

                var polygon = that.getPolygon(that.currently_editing_id);
                that.map_listeners.push(telmap.maps.event.addListener(OrderingHelper.map, 'click', function(e) {
                    that.updatePolygonPoint(polygon, -1, e.latLng.lat(), e.latLng.lng());
                }));

                that.map_listeners.push(telmap.maps.event.addListener(OrderingHelper.map, 'rightclick', function(e) {
                    var path = polygon.getPath();
                    if (path) {
                        path.removeAt(path.length - 1);
                    }
                }));

                that.map_listeners.push(telmap.maps.event.addListener(OrderingHelper.map, "mousemove", function(e) {
                    var distances = $.map(polygon.getPath().array, function(p, i) {
                        return that.pointDistance(p, e.latLng);
                    });
                    var min_index = distances.indexOf(Math.min.apply(null, distances));
                    if (! that.drag_marker || that.drag_marker.getPosition() != polygon.getPath().getAt(min_index)) {
                        that.createDragMarker(polygon, min_index);
                    }
                }));

            }
        },

        createDragMarker        : function (polygon, point_index) {
            var that = this;
            that.removeDragMarker();
            var path = polygon.getPath();
            var point = path.getAt(point_index);
            var icon_image = new telmap.maps.MarkerImage("/static/images/polygon_drag_marker.png", undefined, undefined, {x:5, y:5});
            that.drag_marker = new telmap.maps.Marker({
                map:        OrderingHelper.map,
                position:   point,
                draggable:  true,
                icon:       icon_image,
                cursor:     'move',
                title:      'Drag to edit polygon'
            });
            telmap.maps.event.addListener(that.drag_marker, 'dragend', function(e) {
                path.setAt(point_index, that.drag_marker.getPosition());
                polygon.setPath(path);
                polygon.setMap(OrderingHelper.map);
            });

        },

        deletePoint             : function () {
            var that = this;
            if (that.drag_marker && that.currently_editing_id) {
                var polygon = that.getPolygon(that.currently_editing_id);
                var path = polygon.getPath();
                $.each(path.array, function(i, p) {
                    if (p == that.drag_marker.getPosition()) {
                        path.removeAt(i);
                        that.removeDragMarker();
                        return false;
                    }
                });
            }
        },
        changePolygonColor      : function(p_id, color) {
            var that = this;
            if (p_id in that.polygons) {
                var polygon = that.getPolygon(p_id);
                polygon.setOptions({
                    fillColor: color,
                    strokeColor: color
                });
            }
        },
        removeAllPolygons       : function() {
            var that = this;
            $.each(that.polygons, function (p_id, polygon) {
                polygon.setPath();
                polygon.setMap(null);
            });
            that.polygons = {};
        }

    });
    
    $(function() {

        setTimeout(function() {
            $(document).trigger('map_loaded');
        }, 1000);

        $("#city_areas-group").find("table").tableDnD({
            onDragClass: "row-dragging",
            onDrop: function(table, row) {
                var rows = table.tBodies[0].rows;
                var name_re = /(.*-)\d(-.*)/;
                $.each(rows, function(i, r) {
                    $(r).removeClass("row1 row2");
                    if (i % 2 == 0) {
                        $(r).addClass("row1");
                    } else {
                        $(r).addClass("row2");
                    }

                    $(r).find("td").each(function(j, td) {
                        if ($(td).attr("class") == "original") {
                            return;
                        }
                        var $input = $(td).find("input");
                        if ($input.attr("id")) {
                            $input.attr("id", $input.attr("id").replace(name_re, "$1" + i + "$2"));
                        }
                        if ($input.attr("name")) {
                            $input.attr("name", $input.attr("name").replace(name_re, "$1" + i + "$2"));
                        }
                    })
                });

                console.log(row);
            }
        });
        $(".edit-polygon").live("click", function() {
            MapPointsHelper.doEditPolygon(this.id.replace("edit-", ""));
        });

        $("#city_areas-group").find(".color").find("input").live("change", function() {
            var color = $(this).val();
            var p_id = this.id.replace("color", "points");
            MapPointsHelper.changePolygonColor(p_id, color);
        });

        $(document).keydown(function(e) {
            if (e.keyCode == 46) {
                MapPointsHelper.deletePoint();
            }

        });

        $(document).bind("map_loaded", function() {
            MapPointsHelper.renderPolygons();
            MapPointsHelper.centerMap();
        });


        OrderingHelper.init({
            telmap_user:                "{% value_from_settings "TELMAP_API_USER" %}",
            telmap_password:            "{% value_from_settings "TELMAP_API_PASSWORD" %}",
            telmap_languages:           "he"
        });
    });


    </script>
{% endblock %}

{% block coltype %}colMS{% endblock coltype %}

{% block after_related_objects %}
    <div id="content-related">
        <div id="map_container">
            <div id="map"></div>
        </div>
    </div>
{% endblock %}
